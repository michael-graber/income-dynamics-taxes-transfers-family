function Results = fEstimation(rhoMale,Param)
% Author: Michael Graber
% This file sets up the optimization problem (with age-depencdent variances for
% the transitory and permanent shocks) and uses KNITRO to solve the problem

% NOTE: Here we restrict the variances to be constant over the life cycle (see
% fConstraints.m)

%% Initialise the Problem
%==========================================================================
% Display some information on the screen:
fScreenOutput(Param,rhoMale,[])

% Load Variance Covariance Matrix
[Data.AutoCovMale,~,~,Data.A,Data.age] = fImportData(rhoMale,[],Param);

%% Initial Guess
%==========================================================================
vX0 = [0.1*ones(Data.A,1);   % sigma2Male
       0.02*ones(Data.A+2,1); % omega2Male 
       0.02;                  % VarAlphaMale
       0.25];                 % thetaMale
             
%% Equally Weighted Minimum Distance Estimation
%==========================================================================
% Linear Constraints and bounds on the parameters
[Aeq,beq,lb,ub] = fConstraints(vX0,Data.A);


if strcmp(Param.GradFlag,'on') % use analytical Gradient and Hessian (Gauss-Newton)
    
    % Set some Matlab user options.
    options = optimset( 'HessFcn', @(vX,lambda)fHessian(vX,lambda,rhoMale,Data.A), 'Hessian', 'user-supplied');   
    
    % Equallly Minimum Distance Estimator: Weighting Matrix = Identity Matrix
    W = eye(((Data.A + 1) * Data.A)/2,((Data.A + 1) * Data.A)/2);
   
    % Call KNITRO
    [vX,f,ExitFlag]=ktrlink(@(vX)fObjective(vX,Data,rhoMale,W),vX0,[],[],Aeq,beq,lb,ub,[],options,'./knitro_GaussNewton.opt');

elseif strcmp(Param.GradFlag,'off') % use finite difference approximations
    
     % Equallly Minimum Distance Estimator: Weighting Matrix = Identity Matrix
    W = eye(((Data.A + 1) * Data.A)/2,((Data.A + 1) * Data.A)/2);
   
    % Call KNITRO
    [vX,f,ExitFlag]=ktrlink(@(vX)fObjective(vX,Data,rhoMale,W),vX0,[],[],Aeq,beq,lb,ub,[],[],'./knitro.opt');
    
end;    
    
%% Saving Parameters
%==========================================================================

[sigma2Male,omega2Male,VarAlphaMale,thetaMale] = fExtractParam(vX,Data.A);                   
                   
if rhoMale == 1
    VarAlphaMale = NaN;
end;

% Check for Convergence

if ExitFlag == 0 || ExitFlag == -100 % Convergence achieved

    Results = struct(...
    'ExitFlag',ExitFlag,...
    'VarAlphaMale',VarAlphaMale,...
    'VarBetaMale' , NaN,...
    'rhoAlphaBetaMale', NaN,...
    'f',f,...
    'sigma2Male', sigma2Male,...
    'omega2Male',omega2Male,...
    'thetaMale',thetaMale,...
    'age',Data.age,...
    'rhoMale',rhoMale, ...
    'VarAlphaSpouse', NaN, ...
    'CovAlphaMaleSpouse', NaN,...
    'CovBetaMaleSpouse', NaN, ...
    'VarBetaSpouse', NaN,...
    'rhoAlphaBetaSpouse', NaN, ...
    'sigma2Spouse', NaN*ones(Data.A,1),...
    'sigmaMaleSpouse', NaN*ones(Data.A,1),...
    'omega2Spouse', NaN*ones(Data.A+2,1),...
    'omegaMaleSpouse',NaN*ones(Data.A+2,1),...
    'thetaSpouse', NaN,...
    'rhoSpouse',NaN);
        
else % No Convergence or not optimal solution found
    
     % Make a note in Report
     diary on     
     display('===========================================================')
     display('Warning: No Convergence within Maximum Number of Iterations')
     fScreenOutput(Param,rhoMale,[])
     ExitFlag
     display('===========================================================')
     diary off
    
    % Store result with f = inf so that it is never picked as optimal
    Results = struct(...
    'ExitFlag',ExitFlag,...
    'VarAlphaMale',VarAlphaMale,...
    'VarBetaMale' , NaN,...
    'rhoAlphaBetaMale', NaN,...
    'f',inf,...
    'sigma2Male', sigma2Male,...
    'omega2Male',omega2Male,...
    'thetaMale',thetaMale,...
    'age',Data.age,...
    'rhoMale',rhoMale, ...
    'VarAlphaSpouse', NaN, ...
    'CovAlphaMaleSpouse', NaN,...
    'CovBetaMaleSpouse', NaN, ...
    'VarBetaSpouse', NaN,...
    'rhoAlphaBetaSpouse', NaN, ...
    'sigma2Spouse', NaN*ones(Data.A,1),...
    'sigmaMaleSpouse', NaN*ones(Data.A,1),...
    'omega2Spouse', NaN*ones(Data.A+2,1),...
    'omegaMaleSpouse',NaN*ones(Data.A+2,1),...
    'thetaSpouse', NaN,...
    'rhoSpouse',NaN);
       
end;

end