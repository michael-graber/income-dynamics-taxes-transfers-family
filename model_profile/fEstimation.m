function Results = fEstimation(rhoMale,Param)
% Author: Michael Graber
% This file sets up the optimization problem (with age-depencdent variances for
% the transitory and permanent shocks) and uses KNITRO to solve the problem


%% Initialise the Problem
%==========================================================================
% Display some information on the screen:
fScreenOutput(Param,rhoMale,[])

% Load Variance Covariance Matrix
[Data.AutoCovMale,~,~,Data.A,Data.age] = fImportData(rhoMale,[],Param);

%% Initial Guess
%==========================================================================
vX0 = [0.02*ones(Data.A,1);   % \sigma2Male
       0.02*ones(Data.A+2,1); % \omega2Male (including initial conditions prior to start of sample)
       0.01;                  % \VarAlphaMale
       0.001;                 % \VarBetaMale
       0;                     % \rhoAlphaBetaMale
       0.35];                 % \thetaMale
             
%% Equally Weighted Minimum Distance Estimation
%==========================================================================

% Linear Constraints and bounds on the parameters
[Aeq,beq,lb,ub] = fConstraints(vX0,Data.A);

if strcmp(Param.GradFlag,'on') % use analytical Gradient and Hessian (Gauss-Newton)
    
    % Set some Matlab user options.
    options = optimset( 'HessFcn', @(vX,lambda)fHessian(vX,lambda,rhoMale,Data), 'Hessian', 'user-supplied');   
    
    % Equallly Minimum Distance Estimator: Weighting Matrix = Identity Matrix
    W = eye(((Data.A + 1) * Data.A)/2,((Data.A + 1) * Data.A)/2);
   
    % Call KNITRO
    [vX,f,ExitFlag]=ktrlink(@(vX)fObjective(vX,Data,rhoMale,W),vX0,[],[],Aeq,beq,lb,ub,[],options,'./knitro_GaussNewton.opt');
   

elseif strcmp(Param.GradFlag,'off') % use finite difference approximations
    
     % Equallly Minimum Distance Estimator: Weighting Matrix = Identity Matrix
    W = eye(((Data.A + 1) * Data.A)/2,((Data.A + 1) * Data.A)/2);
   
    % Call KNITRO
    [vX,f,ExitFlag]=ktrlink(@(vX)fObjective(vX,Data,rhoMale,W),vX0,[],[],Aeq,beq,lb,ub,[],[],'./knitro.opt');
    
end;    

%% Saving Parameters
%==========================================================================

[sigma2Male,omega2Male,VarAlphaMale,VarBetaMale,rhoAlphaBetaMale,thetaMale] = fExtractParam(vX,Data.A);             


if rhoMale > .99
    VarAlphaMale     = NaN;
    rhoAlphaBetaMale = NaN;
end;

% Check for Convergence

if ExitFlag == 0 || ExitFlag == -100 % Convergence achieved
    
   Results = struct(...
    'ExitFlag',ExitFlag,...
    'VarAlphaMale',VarAlphaMale,...
    'VarBetaMale' ,VarBetaMale,...
    'rhoAlphaBetaMale',rhoAlphaBetaMale ,...
    'f',f,...
    'sigma2Male', sigma2Male,...
    'omega2Male',omega2Male,...
    'thetaMale',thetaMale,...
    'age',Data.age,...
    'rhoMale',rhoMale, ...
    'VarAlphaSpouse', NaN, ...
    'CovAlphaMaleSpouse', NaN,...
    'CovBetaMaleSpouse', NaN, ...
    'VarBetaSpouse', NaN,...
    'rhoAlphaBetaSpouse', NaN, ...
    'sigma2Spouse', NaN*ones(Data.A,1),...
    'sigmaMaleSpouse', NaN*ones(Data.A,1),...
    'omega2Spouse', NaN*ones(Data.A+2,1),...
    'omegaMaleSpouse',NaN*ones(Data.A+2,1),...
    'thetaSpouse', NaN,...
    'rhoSpouse',NaN);
    
else % No Convergence or not optimal solution found
    
     % Make a note in Report
     diary on     
     display('===========================================================')
     display('Warning: No Convergence within Maximum Number of Iterations')
     fScreenOutput(Param,rhoMale,[])
     ExitFlag
     display('===========================================================')
     diary off
    
    % Store result with Norm = inf so that it is never picked as optimal
     Results = struct(...
    'ExitFlag',ExitFlag,...
    'VarAlphaMale',VarAlphaMale,...
    'VarBetaMale' ,VarBetaMale,...
    'rhoAlphaBetaMale',rhoAlphaBetaMale ,...
    'f',inf,...
    'sigma2Male', sigma2Male,...
    'omega2Male',omega2Male,...
    'thetaMale',thetaMale,...
    'age',Data.age,...
    'rhoMale',rhoMale, ...
    'VarAlphaSpouse', NaN, ...
    'CovAlphaMaleSpouse', NaN,...
    'CovBetaMaleSpouse', NaN, ...
    'VarBetaSpouse', NaN,...
    'rhoAlphaBetaSpouse', NaN, ...
    'sigma2Spouse', NaN*ones(Data.A,1),...
    'sigmaMaleSpouse', NaN*ones(Data.A,1),...
    'omega2Spouse', NaN*ones(Data.A+2,1),...
    'omegaMaleSpouse',NaN*ones(Data.A+2,1),...
    'thetaSpouse', NaN,...
    'rhoSpouse',NaN);
end;

end